在应用程序中，需要知道zookeeper集合的状态，例如：备份主节点需要知道主要主节点已经崩溃，从节点需要知道任务分配给了自己，
甚至zookeeper的客户端会定时轮询zookeeper集合，检查系统状态是否发生变化。

单次触发器：
当应用程序注册了一个监视点来接收通知，匹配该监视点条件的第一个事件会触发监视点的通知，并且最多只触发一次。例如，当znode节点/z被删除，
客户端需要知道该变化，客户端在/z节点执行exists操作并设置监视点标志位，等待通知，客户端会以回调函数的形式收到通知。

getData、getChildren、exists，均可选择在读取的znode节点上设置监视点。使用监视点机制，我们需要实现Watcher接口类，实现其中的process方法。

监视点有两种类型：数据监视点和子节点监视点。创建、删除或设置一个znode节点的数据都会触发数据监视点，exists和getData这两个操作可以设置数据监视点。
只有getChildren操作可以设置子节点监视点。

另一种调用方式multiop：
在multiop代码块中所有的操作要不全部成功，要不全部失败。使用multiop，我们可以原子化创建任务分配节点和删除/tasks下对应的任务节点这两个操作。使用这个方式，我们可以保证
没有已分配额任务还在/tasks下，如果备份节点接管了主节点角色，就不用再区分/tasks下的任务是不是没有分配的。

通过监视点来代替显示缓存管理：
从应用的角度来看，客户端每次都是通过访问zookeeper来获取给定znode节点的数据，一个znode节点的子节点列表或其他相关的zookeeper状态，
这种方式并不可取，反而更高效的方式为客户端本地缓存数据，并在需要时使用这些数据，一旦这些数据发生变化，你让zookeeper通知客户端，
客户端就可以更新缓存的数据。这些通知与我们之前所讨论的一样，应用的客户端通过注册监视点来接收这些通知消息。

避免在一个特定节点设置大量的监视点，最好是每次在特定的znode节点上，只有少量的客户端设置监视点，理想情况下最多只设置一个。