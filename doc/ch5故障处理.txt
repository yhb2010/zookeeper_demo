当一个进程失去连接后就无法收到zookeeper的更新通知，尽管这听起来没什么，但是一个进程也许会在会话丢失时错过了某些重要的状态
变化。客户端c1作为群首，在t2时刻失去了连接，但是并没有发现这个情况，直到t4时刻才声明为终止状态，同时，会话在t2时刻过期，
在t3时刻另一个进程成为群首，从t2到t4时刻旧的群首并不知道它自己被声明为终止状态，而另一个群首已经接管控制。
1、客户端c1与zookeeper失去连接
2、通知客户端c2客户端c1终止
3、客户端c2成为群首
4、客户端c1重连接zookeeper且发现连接失效
如果开发者不仔细处理，旧的群首会继续担当群首，并且其操作可能与新的群首相冲突。

为了使连接断开与重新建立会话之间更加平滑，zookeeper客户端库会在新的服务器上重新建立所有已存在的监视点。当客户端连接zookeeper
的服务器，客户端会发送监视点列表和最后已知的zxid（最终状态的时间戳），服务器会接受这些监视点并检查znode节点的修改时间戳与
这些监视点是否对应，如果任何已经监视的znode节点的修改时间戳晚于最后已知的zxid，服务器就会触发这个监视点。

exists操作与其他操作不同，因为这个操作可以在一个不存在的节点上设置监视点，如果我们仔细看前一段中所说的注册监视点逻辑，我们
会发现存在一种错过监视点事件的特殊情况。例如：客户端监视/event节点的创建事件，然而就在/event被另一个客户端创建时，设置了
监视点的客户端与zookeeper失去连接，在这段时间，其它客户端删除了/event，因此当设置了监视点的客户端重新与zookeeper建立连接
并注册监视点，zookeeper服务器已经不存在/event节点了，因此，当处理只是注册了这个监视点，最终导致客户端错过了/event的创建事件。
因为特殊情况，你需要尽量避免监视一个znode节点的创建事件，如果一定要监视创建事件，应尽量监视存活期更长的znode节点，否则这种
特殊情况可能会伤害你。